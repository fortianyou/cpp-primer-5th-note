
第二章 变量和基本类型
======

2.1 基本内置类型
-----

C++ 定义了一套包括**算术类型**(arithmetic type)和**空类型**(void)在内的基本数据类型.

**算术类型**: 分为两类**整型**(包括字符和布尔类型在内)和**浮点型**.

C++规定一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long至少和一个long一样大.其中，数据类型long long是在C++11中新定义的.

浮点型可表示单精度、双精度和扩展精度值.通常，float以一个字(32bit)来表示，double以2个字(64bit)来表示, long double以3或4个字来表示.一般来说，类型float和double分别有7和16个有效位；类型long double则常常被用于有特殊浮点需求的硬件.

与其他整型不同，字符型分为三种：char、signed char和unsigned char. 特别需要注意的是char和signed char并不一样. 类型char在不同机器上会表现为上述的另外两种形式之一. 因此，不推荐在算术表达是中使用char类型.

给unsigned int类型变量赋予一个int类型的负值，是将补码赋予变量. 当有符号类型与无符号类型混用时通常会将有符号类型转为无符号类型, 造成异常.

**转义字符**:C++中可以使用泛化的转义序列，其形式是\x后紧跟1个或多个16进制数字，或者\后紧跟1-3个8进制数字，其中数字部分表示的是字符对应的数值。

**注意**：如果\后紧跟超过3个数字，则只有前三个数字参与构建转义序列。


2.2 变量
-------
**note**: 在C++中初始化和赋值是两种完全不同的操作。

**列表初始化**：作为C++11标准的一部分，用花括号来初始化变量的方法称之为列表初始化。这种初始化有一个重要的特点：如果初始值存在丢失风险，则编译器讲报错。

### 分离式编译
分离式编译机制允许讲程序分割为若干文件，每个文件可以被独立编译。

为了支持分离式编译，C++将声明和定义分开。

**声明**: 使得名字为程序所知，一个文件如果想使用别的文件定义的名字则必须包含对这个名字的声明。声明一个变量需要在变量之前添加关键字`extern`.

**定义**: 负责创建与名字关联的实体。

变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量初始化。

```
extern int i; //声明了一个变量
extern int j = 0; //定义了一个变量, 一旦extern修饰的变量被初始化则不再是声明
int k; //定义了一个变量
```
**note**：在函数体内，如果试图初始化一个extern修饰的变量，将引发错误。

**note**：变量只能被定义一次，但是能够被多次声明。

复合类型
------

### 引用
引用并非对象, 而是已经存在的对象的一个别名。

引用必须初始化, 并且**只能绑定到对象**上，而不能与字面值或者某个表达式的计算结果绑定在一起。

### 指针
指针和引用一样是复合类型, 实现了对另外一个对象的间接访问。

指针与引用的区别：
1. 指针本身就是一个对象, 允许对指针赋值和拷贝, 并且在生命周内它可以先后指向多个不同的对象.
2. 指针无须在定义时赋值.

```
int &x = i; // &是表示引用类型声明
int *p;  // *表示指针类型声明.
p = &i;  // &是取地址符
int &y = *p; // *是表示解引用符, 返回的是一个对象, 因此可以被用于初始化引用.
```


```

double dval = 1.12;
int ival = 2;

/*
编译器会创建一个临时变量
int tmp = dval;
const int &r1 = tmp;
int &r3 = dval; //错误！！此时引用了可以修改的临时变.
*/
const int &r1 = dval; // r1 引用了 tmp, 但是不能修改
const int &r2 = ival;
cout << r1 << "=1, " << r2 << "=2"<< endl;

dval = 3.02;
ival = 4;
cout << r1 << "=1, " << r2 << "=4"<< endl;

输出:
1=1 2=2
1=1 4=4
```

### 指针和const

指向const的指针，const指针.

```
const double *const ptr = NULL;
从右向左阅读上面的表达式，能够更容易的读出含义.

顶层const: 第一个const修饰的是ptr, 说明ptr本身是一个常量.
声明符中的下一个符号*说明ptr是一个指针. 到目前为止, 我们声明了一个const指针(指针是一个不能改变的对象)

底层const: 第二个const修饰的是double, 说明这是一个指向double常量的常量指针.
```

**顶层const**: 对象本身是个常量.

**底层const**: 指针指向的对象是一个常量.

### 常量表达式

**常量表达式**是指值不会改变并且在编译阶段就能够得到计算结果的表达式.
```
const int a = 20;
const int b = a + 1;
//上面个两个表达式都是常量表达式

const int c = func();// 不是常量表达式. 
```

**constexpr*C++新规定。将变量声明为constexpr类型以便有编译器来验证变量的值是否是一个常量表达式.(使用constexpr显然是有好处的)

**字面值类型**：包括算术类型, 引用和指针.

constexpr只能用来修饰**字面值类型**.

constexpr用来修饰指针时，指针的初始值必须是0, nullptr, 或者存储于某个固定地址的对象. (在编译时便能确定指针的指向)

函数体外的对象的地址固定不变. 函数体内的一般来说不确定.

**NOTE**: constexpr声明中如果定义了指针, 那么限定符constexpr修饰的是指针, 而不是指针指向的对象.
```
int j = 0; // j 必须定义在函数体之外
constexpr double *ptrj = &j; // 常量表达式指针
const int i = 0; // i 必须定义在函数体之外
constexpr const double *ptri = &i; // 常量表达式指针, 指向常量对象
```

### decltype类型指示符
decltype(expr) 返回表达式expr的类型
```
int *p = nullptr;
decltype(*p) //*p的解引用得到的类型是引用类型即int&
decltype(*p) c; //语法错误, int& c 必须初始化

decltype((variable))得到的类型也是引用
```